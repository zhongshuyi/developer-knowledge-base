---
order: 2
---

# Redis

Redis 是一款内存高速缓存数据库。Redis 全称为：Remote Dictionary Server（远程数据服务），使用 C 语言编写，Redis 是一个 key-value 存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis 是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

## 信息来源

Java 全栈知识体系 <https://www.pdai.tech/md/db/nosql-redis/db-redis-introduce.html>

JavaGuide:<https://javaguide.cn/distributed-system/distributed-lock-implementations.html>

ChatGPT

<https://blog.csdn.net/agonie201218/article/details/123640871>

## 目录

- [信息来源](#信息来源)
- [目录](#目录)
- [相关链接](#相关链接)
- [使用场景](#使用场景)
  - [数据库缓存](#数据库缓存)
  - [分布式数据共享](#分布式数据共享)
  - [分布式锁](#分布式锁)
  - [全局唯一 ID 生成](#全局唯一-id-生成)
  - [计数器](#计数器)
  - [限流](#限流)
  - [点赞、签到等功能实现](#点赞签到等功能实现)
  - [排行榜](#排行榜)
  - [延时操作](#延时操作)
  - [简单队列](#简单队列)
- [其他信息](#其他信息)
  - [Redis 为什么这么快？](#redis-为什么这么快)

## 文档目录

- [Redis](/数据库/Redis/)
  - [数据类型](/数据库/Redis/1-数据类型.md)
  - [Redis Stream](/数据库/Redis/2-Redis%20Stream.md)


## 相关链接

Redis 官网:<http://redis.io/Redis>

官方文档:<http://redis.io/documentationRedis>

下载:<http://redis.io/download>

## 使用场景

### 数据库缓存

Redis 最常见的用途是作为缓存层。将常用的数据存储在内存中，可以显著提高读取速度，并减轻后端数据库的负载压力。

一般有两种方案：

- 读取数据时先读取 Redis 中的数据，如果 Redis 中没有数据的话再去数据库中读取，读取后再将数据写入到 Redis 中
- 对数据库操作的同时对 Redis 中的数据进行管理

两种方案都有各自的缺点与优点，需要根据使用场景选择适合的方案

### 分布式数据共享

多个服务之间共享数据、状态等，这时候就可以使用 Redis 作为中间件来实现了

例如：分布式 Session

### 分布式锁

如今都是分布式的环境下 Java 自带的单体锁已经不适用了

一个最基本的分布式锁需要满足：

- 互斥：任意一个时刻，锁只能被一个线程持有。
- 高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。
- 可重入：一个节点获取了锁之后，还可以再次获取锁。

除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：

- 高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。
- 非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。

在 `Redis` 中，SETNX 命令是可以帮助我们实现互斥。`SETNX` 即 SET if Not eXists (对应 Java 中的 setIfAbsent 方法)，如果 `key` 不存在的话，才会设置 `key` 的值。如果 `key` 已经存在，`SETNX` 啥也不做。

### 全局唯一 ID 生成

分布式系统中由于跨进程跨系统，在某些场景中，我们需要生成全局的唯一 ID，例如订单系统，并发情况下，不同的系统需要同时生成不一样的订单 ID 方便后续的订单下单与查询等等。

`redis` 生成全局唯一 ID 的原理

我们生成的订单号一般需要存在 `Long` 类型中，正好 `Long` 类型是 64 位，所以将第一位永远设置成 0，表示正数。后面 31 位表示时间戳，可以表示的数字为 2 的 31 次方（0-2147483648），单位秒，再后面的 32 位可以表示成 2 的 32 次方的订单号（0-4294967296）。这种思想主要是借鉴雪花算法的原理。

1.符号位：1bit，永远为 0，表示正数
2.时间戳：31bit，最大 2147483648 秒，大概 69 年
3.序列号：32bit，最大 4294967296，表示一秒中内能生成的不同的订单数（接近 43 亿）
一般一秒中能产生 43 亿个不一样的订单号，基本满足各种电商场景了。

利用 redis 生成全局唯一 ID，其实 redis 扮演的角色就是一个计数器的作用，方便后续的统计

### 计数器

例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入 Redis 再定时同步到数据库

int 类型，incr 方法

例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入 Redis 再定时同步到数据库

计数功能应该是最适合 `Redis` 的使用场景之一了，因为它高频率读写的特征可以完全发挥 `Redis` 作为内存数据库的高效。在 `Redis` 的数据结构中，`string`、`hash` 和 `sorted set` 都提供了 `incr` 方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景：

- 如果应用需要显示每天的注册用户数，便可以使用 string 作为计数器，设定一个名为 REGISTERED_COUNT_TODAY 的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用 incr 命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。
- 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用 `hash` 进行计数会更好，将该计数器的 `key` 设为 `weibo:weibo_id`，`hash` 的 `field` 为 `like_number`、`comment_number`、`forward_number` 和 `view_number`，在对应操作后通过 `hincrby` 使 `hash` 中的 `field` 自增。
- 如果应用有一个发帖排行榜的功能，便选择 `sorted set` 吧，将集合的 `key` 设为 `POST_RANK`。当用户发帖后，使用 `zincrby` 将该用户 `id` 的 `score` 增长 1。`sorted set` 会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。

### 限流

int 类型，incr 方法

以访问者的 ip 和其他信息作为 key，访问一次增加一次计数，超过次数则返回 false

### 点赞、签到等功能实现

详细： <https://blog.csdn.net/qq_34162294/article/details/118383908>

Redis 的位图数据结构可以很方便地用于实现点赞和签到等相关功能。

如果我们每次点赞都实时去修改与查询 MySQL 进行实现，遇到一个热点文章的话就会遇到问题了。这个时候我们可以使用 redis 的位图数据类型

应用场景：

- 用户签到
- 用户在线状态
- 统计活跃用户
- 各种状态值
- 自定义布隆过滤器
- 点赞功能

### 排行榜

使用 `sorted set`(有序 set) 和一个计算热度的算法便可以轻松打造一个热度排行榜

### 延时操作

比如在订单生产后我们占用了库存，10 分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。由于 `redis` 自 2.8.0 之后版本提供`Keyspace Notifications` 功能，允许客户订阅 `Pub/Sub` 频道，以便以某种方式接收影响 `Redis` 数据集的事件。所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个 `key`，同时设置 10 分钟后过期，我们在后台实现一个监听器，监听 `key` 的实效，监听到 `key` 失效时将后续逻辑加上。

当然我们也可以利用 rabbitmq、activemq 等消息中间件的延迟队列服务实现该需求。

### 简单队列

由于 Redis 有 list push 和 list pop 这样的命令，所以能够很方便的执行队列操作。

## 其他信息

### Redis 为什么这么快？

其他信息可以看看：<https://juejin.cn/post/6978280894704386079>

- Redis 基于内存，相对于数据存在磁盘的数据库，就省去磁盘磁盘 I/O 的消耗。MySQL 等磁盘数据库，需要建立索引来加快查询效率，而 Redis 数据存放在内存，直接操作内存，所以就很快。
- Redis 内置了多种优化过后的数据结构实现，性能非常高。例如字符串，使用了空间预分配与惰性空间释放
- 使用单线程模型，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。
- Redis 直接自己构建了 VM 机制，不会像一般的系统会调用系统函数处理，会浪费一定的时间去移动和请求。虚拟内存机制就是暂时把不经常访问的数据 (冷数据) 从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据 (热数据)。通过 VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。
